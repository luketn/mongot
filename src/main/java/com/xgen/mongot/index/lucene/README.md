## Contents
- [Definitions](#definitions)
- [LuceneAnalyzer](#lucene-analyzer)
- [Indexing In Lucene](#indexing-in-lucene)
- [Highlighting In Lucene](#highlighting-in-lucene)

## Definitions

### Term
A term is the unit of search. Lucene represents a term by its plain text and the field that the text occurred in.

## Lucene Analyzer

The Lucene Analyzer is a [`PerFieldAnalyzerWrapper`](https://lucene.apache.org/core/8_6_1/analyzers-common/org/apache/lucene/analysis/miscellaneous/PerFieldAnalyzerWrapper.html)
object, which is a subclass of the lucene [`Analyzer`](https://lucene.apache.org/core/8_6_1/core/org/apache/lucene/analysis/Analyzer.html) class.

The `PerFieldAnalyzerWrapper` class allows us to [specify](https://lucene.apache.org/core/8_6_1/analyzers-common/org/apache/lucene/analysis/miscellaneous/PerFieldAnalyzerWrapper.html#PerFieldAnalyzerWrapper-org.apache.lucene.analysis.Analyzer-java.util.Map-) both a default index analyzer and path-defined analyzers as well.

## Indexing In Lucene

Lucene can do 3 things with a field:

1. **Index the field.** The field must be indexed if it is to be searched on.
    When Lucene indexes a field, it analyzes the field, a process which generates the tokens for that field.
    
2. **Store the field.** Write a verbatim copy of the un-analyzed field in the index so that it can be retrieved later.
This is necessary for highlighting because we want to be able to display the original text and show hits to the user when we retrieve results.

3. **Term Vectors.** If Lucene is indexing the field, you can optionally create `term vectors` for each term in each document:
To get a term vector, you key first by `docID` to get all of the term vector fields for a given document, and then key secondarily by term to obtain a mini-inverted index for that one document.

    A term vector looks like the following:
    
    `(term) ––> (unique terms, frequencies, positions, offsets)`
    
    `unique terms`: The separate & distinct terms generated by the analyzer
    
    `frequencies`: The frequencies of each term in the document
    
    `positions`: The positions of each occurrence of every term
    
    `offsets`: The start and end character position of each occurrence of every term. The start and end offsets permit applications to re-associate a token with its source text.
    
    **By default**, Atlas Search creates term vectors that store all 4 of these attributes when indexing a string field.
    See the [`indexOptions`](https://docs.atlas.mongodb.com/reference/atlas-search/index-definitions/#string) field for a string field definition in the Atlas Search public docs. 
    
    We also provide the user the ability to specify which subset of these 4 attributes they want to store in the term vector via `indexOptions`.

    
## Highlighting in Lucene

We use Lucene's [`UnifiedHighlighter`](https://lucene.apache.org/core/9_7_0/highlighter/org/apache/lucene/search/uhighlight/UnifiedHighlighter.html)
class.

Conceptually, highlighting requires two separate inputs:

1. The complete, original text to be highlighted (obtained from storing the field at index time)

2. A `TokenStream` derived from that text. There are two ways to derive this `TokenStream`:

    a. Re-analyze the text in memory using the [analyzer](#lucene-analyzer) that is [passed into](https://github.com/mongodb/mongot/blob/c1745aeb5220a0d66c0b3ee4ca332bc71c95c20c/src/main/java/com/xgen/mongot/index/lucene/LuceneUnifiedHighlighter.java#L24)
     `UnifiedHighlighter`. This is done for multi-term queries, like fuzzy, wildcard, etc.
    
    b. Faster option: Use the term vectors for the field if term vectors were created during indexing time. If the term vectors are being used,
    they will need to have the `positions` and `offsets` stored in them (which Atlas Search does by default.)
 
    
