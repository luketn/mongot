package com.xgen.mongot.index;

import com.xgen.mongot.util.bson.parser.BsonDocumentBuilder;
import com.xgen.mongot.util.bson.parser.BsonParseException;
import com.xgen.mongot.util.bson.parser.DocumentEncodable;
import com.xgen.mongot.util.bson.parser.DocumentParser;
import com.xgen.mongot.util.bson.parser.Field;
import org.bson.BsonDocument;
import org.bson.BsonValue;

/**
 * IntermediateFacetBucket represents an intermediate bucket produced for a facet collector query
 * run against a sharded collection. Each bucket contains the type of facet the bucket is for, the
 * path that the bucket data is from, the bucket label, and the count of documents in that bucket.
 * Number and Date facets also have a tag to distinguish them from each other. These intermediate
 * buckets will later be merged using the plan generated by {@link
 * com.xgen.mongot.server.command.search.ShardedSearchPlanner}
 *
 * @param tag The name of the facet.
 * @param bucket The facet boundary, or the string facet value.
 */
public record IntermediateFacetBucket(Type type, String tag, BsonValue bucket, long count)
    implements DocumentEncodable {

  private static class Fields {
    static final Field.Required<Type> TYPE =
        Field.builder("type").enumField(Type.class).asCamelCase().required();

    static final Field.Required<String> TAG = Field.builder("tag").stringField().required();

    static final Field.Required<BsonValue> BUCKET =
        Field.builder("bucket").unparsedValueField().required();

    static final Field.Required<Long> COUNT = Field.builder("count").longField().required();
  }

  public enum Type {
    FACET
  }

  static IntermediateFacetBucket fromBson(DocumentParser parser) throws BsonParseException {
    return new IntermediateFacetBucket(
        parser.getField(Fields.TYPE).unwrap(),
        parser.getField(Fields.TAG).unwrap(),
        parser.getField(Fields.BUCKET).unwrap(),
        parser.getField(Fields.COUNT).unwrap());
  }

  @Override
  public BsonDocument toBson() {
    return BsonDocumentBuilder.builder()
        .field(Fields.TYPE, this.type)
        .field(Fields.TAG, this.tag)
        .field(Fields.BUCKET, this.bucket)
        .field(Fields.COUNT, this.count)
        .build();
  }
}
