package com.xgen.mongot.index.query.sort;

import com.google.common.base.Objects;
import com.google.errorprone.annotations.Var;
import com.xgen.mongot.proto.bson.ProtoSequenceToken;
import com.xgen.mongot.proto.bson.ProtoValue;
import com.xgen.mongot.util.bson.ProtoConverter;
import com.xgen.mongot.util.bson.TypeConversionException;
import com.xgen.mongot.util.bson.parser.BsonParseContext;
import com.xgen.mongot.util.bson.parser.BsonParseException;
import com.xgen.mongot.util.bson.parser.Encodable;
import com.xgen.mongot.util.bson.parser.TypeDescription;
import java.util.Arrays;
import java.util.Base64;
import java.util.List;
import java.util.Optional;
import javax.annotation.Nullable;
import org.apache.lucene.search.FieldDoc;
import org.apache.lucene.search.ScoreDoc;
import org.bson.BsonString;
import org.bson.BsonValue;

/**
 * A SequenceToken wraps a {@link ScoreDoc} and defines mapping to an opaque bson string.
 *
 * <p>A {@link ScoreDoc} represents a point in a total ordering of a result set. This allows us to
 * use Lucene's searchAfter API to prune results to only those that would appear before or after the
 * provided ScoreDoc. Due to sharding, segment merges, and concurrent updates, it is not necessarily
 * true that a SequenceToken corresponds to a live document on this shard. <br>
 *
 * <p>The pagination API differs from GetMore in one key way: paginated queries are not issued
 * within the same session and do not share a cursor. Because of this, the returned results may not
 * be consistent. Some documents may appear on two pages while others that should be returned are
 * skipped entirely. This is caused by concurrent updates shifting scores or a user under-specifying
 * a sort key.
 */
public record SequenceToken(Optional<BsonValue> id, FieldDoc fieldDoc) implements Encodable {
  public SequenceToken(BsonValue id, FieldDoc fieldDoc) {
    this(Optional.of(id), fieldDoc);
  }

  public SequenceToken(FieldDoc fieldDoc) {
    this(Optional.empty(), fieldDoc);
  }

  /**
   * Helper method for parsing a token string.
   *
   * @param token a base 64 string generated by {@link #encode(SequenceToken)}
   */
  public static SequenceToken of(String token) throws BsonParseException {
    return decode(BsonParseContext.root(), token);
  }

  /**
   * Converts the provided {@link ScoreDoc} into an equivalent {@link FieldDoc} if it isn't already,
   * and wraps it in a {@code SequenceToken} object. If {@code scoreDoc} is already a {@link
   * FieldDoc}, this method is equivalent to {@link #SequenceToken(BsonValue, FieldDoc)}.
   */
  public static SequenceToken of(BsonValue id, ScoreDoc scoreDoc) {
    // Depending on whether an explicit sort is present, Lucene APIs may specifically require a
    // FieldDoc (even if the type signature takes a ScoreDoc). It never hurts to always provide
    // a FieldDoc and doing the conversion here keeps the usages of this class clean.
    if (scoreDoc instanceof FieldDoc) {
      return new SequenceToken(id, (FieldDoc) scoreDoc);
    } else {
      return new SequenceToken(id, new FieldDoc(scoreDoc.doc, scoreDoc.score, new Object[0]));
    }
  }

  private static String encode(SequenceToken token) {
    ProtoSequenceToken.Builder builder = ProtoSequenceToken.newBuilder();
    if (token.id().isPresent()) {
      builder.setId(ProtoConverter.convert(token.id().get()));
    }

    builder.setDocId(token.fieldDoc.doc);

    @Nullable Object[] fields = token.fieldDoc.fields;
    if (fields != null && fields.length > 0) {
      for (Object field : fields) {
        builder.addFields(wrap(field));
      }
    } else {
      // Score is not required to resume sorted queries.
      builder.setScore(token.fieldDoc.score);
    }
    return Base64.getEncoder().encodeToString(builder.build().toByteArray());
  }

  /** Decodes a base64 token produced by {@link #encode(SequenceToken)}. */
  private static SequenceToken decode(BsonParseContext context, String tokenStr)
      throws BsonParseException {
    ProtoSequenceToken token;
    try {
      byte[] data = Base64.getDecoder().decode(tokenStr);
      token = ProtoSequenceToken.parseFrom(data);
    } catch (Exception e) {
      // Not base64 or invalid proto format
      return context.handleSemanticError("Invalid format for token value");
    }

    return parseSequenceToken(context, token);
  }

  private static SequenceToken parseSequenceToken(
      BsonParseContext context, ProtoSequenceToken token) throws BsonParseException {
    int docId = token.getDocId();
    @Var float score = token.getScore();
    if (docId < 0) {
      return context.handleSemanticError("Invalid token component");
    }
    if (score < 0) {
      // Score must be NaN or non-negative.
      return context.handleSemanticError("Invalid token component");
    }
    Object[] fields = new Object[token.getFieldsCount()];
    List<ProtoValue> fieldsList = token.getFieldsList();
    for (int i = 0; i < fieldsList.size(); i++) {
      ProtoValue value = fieldsList.get(i);
      fields[i] = unwrap(context, value);
      if (fields[i] instanceof Float) {
        // Float indicates that we sorted by score, which we never encode twice because it can
        // be inferred here.
        score = (Float) fields[i];
      }
    }

    var fieldDoc =
        (fields.length > 0)
            ? new FieldDoc(docId, score, fields, -1)
            // Sequence token came from implicit sort by score. Populate fields array because
            // TopFieldCollector will need it if using searchBefore, and there's no harm in
            // populating it
            // when using TopScoreDocCollector
            : new FieldDoc(docId, score, new Object[] {score}, -1);

    if (token.hasId()) {
      BsonValue id = protoToBson(context, token.getId());
      return new SequenceToken(id, fieldDoc);
    }
    return new SequenceToken(fieldDoc);
  }

  private static Object unwrap(BsonParseContext ctx, ProtoValue sortKey) throws BsonParseException {
    // We don't index ints separately from longs, so we can encode score as an int
    if (sortKey.hasInt32()) {
      return Float.intBitsToFloat(sortKey.getInt32());
    }
    return protoToBson(ctx, sortKey);
  }

  private static BsonValue protoToBson(BsonParseContext ctx, ProtoValue value)
      throws BsonParseException {
    try {
      return ProtoConverter.convert(value);
    } catch (TypeConversionException e) {
      return ctx.handleSemanticError("Invalid token component");
    }
  }

  /**
   * Converts the given {@link FieldDoc#fields} object to a Bson representation.
   *
   * <p>The function guarantees that the original type and value can be reconstructed by {@link
   * #unwrap(BsonParseContext, ProtoValue)}.
   *
   * @param o an object returned by Lucene in {@link FieldDoc#fields}
   */
  private static ProtoValue wrap(Object o) {
    if (o instanceof Float) {
      // This is a score value, return int32 because it isn't used for anything else
      float score = (Float) o;
      return ProtoValue.newBuilder().setInt32(Float.floatToIntBits(score)).build();
    } else if (o instanceof BsonValue) {
      return ProtoConverter.convert(((BsonValue) o));
    } else {
      throw new IllegalArgumentException("No mapping defined for [" + o + "] to BsonValue");
    }
  }

  public static SequenceToken fromBson(BsonParseContext context, BsonValue value)
      throws BsonParseException {
    if (!value.isString()) {
      return context.handleUnexpectedType(TypeDescription.STRING, value.getBsonType());
    }
    return SequenceToken.decode(context, value.asString().getValue());
  }

  @Override
  public BsonValue toBson() {
    return new BsonString(encode(this));
  }

  @Override
  public String toString() {
    return "SequenceToken(" + this.fieldDoc + ")";
  }

  @Override
  public boolean equals(Object o) {
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SequenceToken that = (SequenceToken) o;
    // NB: lucene FieldDoc and ScoreDoc do not implement equals().
    return Objects.equal(this.id, that.id) && fieldDocEquals(this.fieldDoc, that.fieldDoc);
  }

  private static boolean fieldDocEquals(FieldDoc a, FieldDoc b) {
    return a.doc == b.doc
        && a.score == b.score
        && a.shardIndex == b.shardIndex
        && Arrays.equals(a.fields, b.fields);
  }

  @Override
  public int hashCode() {
    return Objects.hashCode(
        this.id,
        this.fieldDoc.doc,
        this.fieldDoc.score,
        this.fieldDoc.shardIndex,
        Arrays.hashCode(this.fieldDoc.fields));
  }
}
