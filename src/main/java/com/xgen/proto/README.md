# Protobuf BSON IDL

This package contains an adaptation of the Protobuf IDL to support BSON messages.

It is divided into a runtime library (in this package) and the plugin (in a subpackage).
There is also a macro to help generate java bson proto libraries.

## Usage

Define a [protobuf](https://protobuf.dev) file containing message definitions:

```protobuf
message Person {
  optional string name = 1;
  optional bytes id = 2;
  optional string email = 3;
  message Pet {
    optional string name = 1;
  }
  repeated Pet pets = 4;
}
```

Use the `java_bson_proto_library()` rule to wrap a `proto_library()` and it will generate the usual
Java protocol buffer API for the message(s) along with extensions to map each message into a Bson
document. You can also place well known types to place Bson constructs within a message, for
instance:

* `ProtoValue` represents an arbitrary Bson value of any type.
* `ProtoDocument` represents a Bson document of any shape.
* `ProtoObjectId` represents a 12-byte `ObjectId` value.

In addition to supporting `optional` and `repeated` field types we also support `map<string, T>`
fields. These are coded as Bson documents although you should prefer `ProtoDocument` if field
order is important as protobuf maps are unordered.

## How It Works

`protoc` is used to generate Java classes from protocol message definitions with defined insertion
points. `protoc` then invokes our plugin (`JavaBsonProtoPlugin`) which inserts code into these
points for all input messages. This generates additional API elements that work with `BsonWriter`
and `BsonReader` class to support BSON serialization and de-serialization.

`Message` classes generated by the compiler get the following additional methods:

* `void writeBsonTo(BsonWriter)`
* `BsonDocument toBsonDocument()`
* `byte[] toBsonByteArray()`
* `static T parseBsonFrom(BsonReader)`
* `static T parseBsonFrom(BsonDocument)`
* `static T parseBsonFrom(byte[])`
  `Message.Builder` classes generated by the compiler get the following additional methods:
* `mergeBsonFrom(BsonReader)`

These classes still have the default generated code so they may be serialized to protobuf wire
format.

There are additional protobuf messages defined for well-known types that represent BSON concepts,
including `ProtoDocument` to represent arbitrary BSON documents and `ProtoValue` to represent
arbitrary BSON values. These messages may be placed inside another message and encoded in the
expected way. This allows you to insert an arbitrary BSON document or value within another protobuf
message. These value messages will have additional methods to help with conversion from
`BsonValue` types including:

* `Builder.mergeBsonFrom(<appropriate BsonValue subtype>)`
* `Builder.mergeBsonFrom(BsonValue)`
* `Message.parseBsonFrom(<appropriate BsonValue subtype>)`
* `Message.parseBsonFrom(BsonValue)`

For well-known types the variants that accept `BsonValue` subtypes will not throw exceptions making
them quite convenient, e.g. `ProtoValue.parseBsonFrom(new ObjectId(...));`

## Field naming

The [Protocol Buffer Style Guide](https://protobuf.dev/programming-guides/style/#message-field-names)
states that field should be named using `lower_snake_case`. For Bson messages we use field names
generated by protobuf's json support. The default bson name is generated by protobuf's json support
and is just the snake case name converted to `lowerCameCase` but you may also set the `json_name`
field option to override the name if needed.

```protobuf
message Song {
  // This field serializes as "songName": <value> in Bson.
  optional string name = 1 [json_name = "songName"];
}
```

## Discriminated Unions

Bson messages often use a flattened discriminated union representation for messages e.g.

```json
{
  "indexType": "vector",
  "indexName": "songs",
  "numDimensions": 1024
}
```

In this case `indexName` is a property of all messages but `numDimensions` is specific to the
`vector` `indexType`. `oneof` is similar in purpose but does not map well to this message shape as
it expects there to be a field named `vector` or similar. This plugin implements a field option that
allows us to map this message shape to protocol buffers:

```protobuf
message Index {
  option (bson.protobuf.message_options).message_type = DISCRIMINATED_UNION;

  message Search {
    optional string analyzer = 1;
  }
  message Vector {
    optional int32 num_dimensions = 1;
  }

  optional string name = 1;
  oneof index_type {
    Search search = 2;
    Vector vector = 3;
  }
}
```

When the `discriminated_union` message option is set we will expect a field named `indexType` that
with a value the maps to a field name in the `oneof index_type`. Fields belonging to the base
message type are parsed first, then the correct variant message is parsed (if `indexType` is
present in the message). Settings for `allow_unknown_fields` are obeyed.

The plugin enforces several constraints on use of `discriminated_union`:

* Messages may only have one `oneof` field.
* All members of the `oneof` must be message-typed.
* All members of the `oneof` may not be `discriminated_union` message types.
* Each non-`oneof` field in the discriminated union may not conflict with the name of any field in
  any of the variant messages to avoid an ambiguous parse. In the example above, neither `Search`
  nor `Vector` may have a field called `name`.

## Type Union and Value Messages

Bson messages may often have named fields that can contain a number of different types but not all
possible types -- essentially a union field that is more restricted than `BsonValue`. For instance:

```json
{
  "point": <double
  |
  int64
  |
  GeoPointDocument>
}
```

To support this the plugin implements a message option to treat a message as Bson _value_ for a
field and not as a top level document/message type. Within a value message we can place a `oneof` to
represent the union. Unlike other message types the names of these fields are not parsed, only the
type is considered. For example, the message above could be parsed with:

```protobuf
message Point {
  option (bson.protobuf.message_options).message_type = VALUE;
  oneof point {
    double float_point = 1;
    int64 long_point = 2;
    GeoPointDocument geo_point = 3;
  }
}

message Doc {
  optional Point point = 1;
}
```

Protobuf imposes a restriction on `oneof` where the members are scalar, never repeated. In order to
support `ARRAY` within a type union message we can use another value message with a single field:

```protobuf
message FloatVector {
  repeated float dim = 1;
}

message Point {
  option (bson.protobuf.message_options).message_type = VALUE;
  oneof point {
    double float_point = 1;
    int64 long_point = 2;
    GeoPointDocument geo_point = 3;
    FloatVector vector_point = 4;
  }
}
```

Type Unions and Value Messages have several restriction enforced by the compiler:

* A `VALUE` message may have a repeated field or a `oneof` with any number of members.
* Members of a `oneof` field must all have different Bson types. In particular this means you cannot
  use multiple document types within the value oneof.

## `map` fields

Protobuf also allows `map<K, V>` fields with a limited set of accepted key types and an arbitrary
value type. protobuf-bson only supports `map<string, T>` -- all other keys types are disallowed.
Maps with string keys are coded as Bson documents, other key types would require much less efficient
coding schemes although this may be implemented in the future.

`map<string, T>` differs from `ProtoDocument` in several ways:

* Protobuf `map` is unordered while `ProtoDocument` preserves field order.
* `map` disallows repeated keys; `ProtoDocument` preserves them like `RawBsonDocument`.
* `map` imposes schema on field values unless you use `map<string, ProtoValue>`.

If order and preserving repeated keys is not important this can be useful for Bson models where the
key is arbitrary but maps to a value of a fixed schema.

## Numeric Type Semantics

When parsing numeric values from Bson streams we may accept values of types other than the nearest
mapping. Specifically:

* 32-bit integer fields may also be parsed from `INT64` or `DOUBLE` Bson values so long as the value
  can be converted without truncation.
* 64-bit integer fields are parsed from `INT32` Bson values unconditionally. They may be parsed from
  `DOUBLE` Bson values so long as they can be converted without truncation.
* 32-bit float fields are parsed from `INT32` and `INT64` Bson values unconditionally. They may be
  parsed from `DOUBLE` Bson value so long as they can be converted without truncation.
* 64-bit float fields are parsed from `INT32` and `INT64` Bson values unconditionally.

## A note on scalar/repeated semantics

Any field declared as `repeated` will be serialized as a BSON array of the underlying type. In some
cases it may be desirable to allow a bare single value to be parsed into the array field; we allow
this using the `allow_single_value` field option:

```protobuf
message Search {
  repeated string field_name = 1 [(bson.protobuf.field_options).allow_single_value = true];
}
```

When set both `{"fieldName": "foo"}` and `{"fieldName": ["foo", "bar"]}` will be accepted for this
message definition. This is maintained in serialization as well: if only a single value is present
the array is elided.

This option may not be used on any field whose underlying type may contain an array as this would
cause parsing to be ambiguous. This constraint is enforced by the compiler plugin. Today this means
that `ProtoArray` and `ProtoValue` typed fields may not use this option, but this may apply to other
message types in the future.

## Migrating

There are two ways to approach this for any given hierarchy of messages:

* Top-down: replace the top-level message that is coded (the request or response). Set all fields in
  this message to be `ProtoValue` or a primitive type if reasonable. Slowly fix replace the field
  types as part of the message hierarchy are fixed to use protobuf representation.
* Bottom-up: use the `Field.protoField` within the existing BSON parser framework to replace leaf
  messages with protocol buffers. Like `Field.classField` you will need to specify a parser method
  (`T::parseBsonFrom` will always work) and may allow or disallow unknown fields in the immediate
  message and any sub-messages.

### Caveats/Known Issues

This list is almost certainly incomplete.

* Enum type handling. We only accept string values and do not accept unknown value even if the enum
  type is open. Enums should serialize as integer by default with an option to serialize as string.
* Generated code for well-known types allows them to be serialized to BSON which should fail with an
  unchecked exception.
* Serialization may fail if well-known type messages contain invalid representations. This currently
  happens as unchecked (IllegalState) exceptions.
* Unknown fields are not preserved, so they cannot be examined or further propagated through
  subsequent serialization. This may be implemented in the future.
* Protobuf `map` types only support `string` keys. Other key types would force a very inefficient
  message coding so it is unlikely that we would implement this.
* No support for representing map-like entities as documents. Specifically we could allow
  `repeated MyEntry` to be represented as a doc provided that the message type had a string key and
  an arbitrary value field and no other fields.
